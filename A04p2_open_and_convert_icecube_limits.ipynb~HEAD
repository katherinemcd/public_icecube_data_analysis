{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import glob\n",
    "import scipy.interpolate\n",
    "import scipy.integrate\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "\n",
    "def load_Aeff(input_file_names, output_file_name, alpha=2.5):\n",
    "    \n",
    "    data_E = np.array([])\n",
    "    data_dec = np.array([])\n",
    "    data_Aeff = np.array([])\n",
    "\n",
    "    df = pd.DataFrame()    \n",
    "    for data_file in input_file_names:\n",
    "        df = pd.concat([df, pd.read_fwf(data_file, header=None, skiprows=1)])\n",
    "\n",
    "    data_E = (df[0].to_numpy() + df[1].to_numpy()) / 2\n",
    "    data_dec = (df[2].to_numpy() + df[3].to_numpy()) / 2\n",
    "    data_Aeff = df[4].to_numpy()\n",
    "    \n",
    "    data_E = np.power(10.0, data_E) / 1000.0  # convert to TeV\n",
    "\n",
    "    '''\n",
    "    plt.figure()\n",
    "    for i_unique_E, unique_E in enumerate(np.unique(data_E)):\n",
    "        if(unique_E < 1000.0):\n",
    "            continue\n",
    "        \n",
    "        allowed_values = np.logical_and(data_E == unique_E, data_Aeff != 0)\n",
    "        data_dec_ = data_dec[allowed_values]\n",
    "        data_Aeff_ = data_Aeff[allowed_values]\n",
    "        argsort_ = np.argsort(data_dec_)\n",
    "        data_dec_ = data_dec_[argsort_]\n",
    "        data_Aeff_ = data_Aeff_[argsort_]        \n",
    "        plt.semilogy(data_dec_,\n",
    "                     data_Aeff_,                     \n",
    "                     label=np.round(np.log10(unique_E), 2))\n",
    "    plt.legend()\n",
    "    plt.show()\n",
    "    '''\n",
    "    \n",
    "    # So, now have to integrate Aeff as function of declination\n",
    "    unique_decs = np.unique(data_dec)\n",
    "    x_dec_steps = np.zeros(len(unique_decs))\n",
    "    y_integrate_steps = np.zeros(len(unique_decs))\n",
    "\n",
    "    for i_unique_decs, unique_decs in enumerate(unique_decs):\n",
    "\n",
    "        cur_E_max = data_E[data_dec == unique_decs]\n",
    "        cur_Aeff = data_Aeff[data_dec == unique_decs]\n",
    "        \n",
    "        allowed_events = cur_Aeff != 0.0\n",
    "        cur_E_max = cur_E_max[allowed_events]\n",
    "        cur_Aeff  = cur_Aeff[allowed_events]\n",
    "        \n",
    "        argsort_ = np.argsort(cur_E_max)\n",
    "        cur_E_max = cur_E_max[argsort_]\n",
    "        cur_Aeff = cur_Aeff[argsort_]\n",
    "\n",
    "        # so the Aeff is different year on year\n",
    "        # better ways to solve it, but for now just average\n",
    "        unique_energies = np.unique(cur_E_max)\n",
    "        unique_Aeff = np.zeros(len(unique_energies))\n",
    "        for i in range(len(unique_Aeff)):\n",
    "            unique_Aeff[i] = np.mean(cur_Aeff[cur_E_max == unique_energies[i]])\n",
    "\n",
    "        # functional time\n",
    "        f_integrand = scipy.interpolate.interp1d(unique_energies, \n",
    "                                                 np.power(unique_energies, -alpha) * unique_Aeff,\n",
    "                                                 kind='linear',\n",
    "                                                 bounds_error=False,\n",
    "                                                 fill_value=0)\n",
    "\n",
    "        integrated_Aeff, int_Aeff_error = scipy.integrate.quad(f_integrand,\n",
    "                                                               np.min(unique_energies),\n",
    "                                                               np.max(unique_energies),\n",
    "                                                               limit=5000)\n",
    "\n",
    "        x_dec_steps[i_unique_decs] = unique_decs\n",
    "        y_integrate_steps[i_unique_decs] = integrated_Aeff\n",
    "\n",
    "        print(\"%i \\t %.2f \\t %.2f \\t %.2f \\t %.2f \" % (i_unique_decs,\n",
    "                                                       unique_decs,\n",
    "                                                       np.min(cur_E_max),\n",
    "                                                       np.max(cur_E_max),\n",
    "                                                       integrated_Aeff))\n",
    "\n",
    "    # sort steps, just in case\n",
    "    x_dec_steps, y_integrate_steps = zip(*sorted(zip(x_dec_steps, y_integrate_steps)))\n",
    "    x_dec_steps = np.array(x_dec_steps)\n",
    "    y_integrate_steps = np.array(y_integrate_steps)\n",
    "\n",
    "    x_dec_steps = x_dec_steps[y_integrate_steps > 0.0]\n",
    "    y_integrate_steps = y_integrate_steps[y_integrate_steps > 0.0]\n",
    "\n",
    "    x_dec_steps = x_dec_steps[np.logical_not(np.isinf(y_integrate_steps))]\n",
    "    y_integrate_steps = y_integrate_steps[np.logical_not(np.isinf(y_integrate_steps))]\n",
    "\n",
    "    np.savez(output_file_name,\n",
    "             dec=x_dec_steps,\n",
    "             Aeffintegrated=y_integrate_steps)\n",
    "        \n",
    "    return x_dec_steps, y_integrate_steps\n",
    "\n",
    "\n",
    "if(__name__ == \"__main__\"):\n",
    "\n",
    "    input_file_names = glob.glob(\"./data/icecube_10year_ps/irfs/*effectiveArea.csv\")\n",
    "\n",
    "    for alpha in [2.0, 2.5]:\n",
    "    \n",
    "        output_file_name = \"./processed_data/output_icecube_AffIntegrated_%s.npz\" % alpha    \n",
    "        dec_steps, y_integrate_steps = load_Aeff(input_file_names, output_file_name, alpha)\n",
    "\n",
    "        plt.plot(dec_steps, y_integrate_steps, label=\"alpha= %.2f\" % alpha)\n",
    "\n",
    "    plt.xlabel(\"Dec [Deg]\")\n",
    "    plt.ylabel(\"Integrated Aeff(Dec, E) / E^alpha dE\")\n",
    "    plt.grid()\n",
    "    plt.legend()\n",
    "    plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
